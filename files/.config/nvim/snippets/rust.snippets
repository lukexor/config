snippet const "constant" b
    const $1: $2 = $0;
snippet stat "static" b
    static $1: $2 = $0;
snippet stats "static str" b
    static $1: &'static str = "$0";

snippet fn "fn" b b
    fn $1($2)$3 {
        ${0:${VISUAL}}
    }

snippet pfn "pub fn" b
    pub fn $1($2)$3 {
        ${0:${VISUAL}}
    }

snippet pcfn "pub(crate) fn" b
    pub(crate) fn $1($2)$3 {
        ${0:${VISUAL}}
    }

snippet psfn "pub(super) fn" b
    pub(super) fn $1($2)$3 {
        ${0:${VISUAL}}
    }

snippet afn "async fn" b
    async fn $1($2)$3 {
        ${0:${VISUAL}}
    }

snippet pafn "pub async fn" b
    pub async fn $1($2)$3 {
        ${0:${VISUAL}}
    }

snippet || "closure" i
    ${1:move }|$2| { ${0:${VISUAL}} }

snippet new "new" b
    fn new($1) -> ${2:Self} {
        $2 { $0 }
    }

snippet pnew "pub new" b
    pub fn new($1) -> ${2:Self} {
        $2 { $0 }
    }

snippet main "main" b
    fn main() {
        ${0:${VISUAL}}
    }

snippet pr "print!" b
    print!("$1"$0);

snippet prln "println!" b
    println!("$1"$0);

snippet fmt "format!"
    format!("$1"$0);

snippet st "struct"
    #[derive(Debug)]
    #[must_use]
    struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
        ${0:${VISUAL}}
    }

snippet stn "struct w/ constructor"
    #[derive(Debug)]
    #[must_use]
    pub struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
        ${0:${VISUAL}}
    }

    impl$2 $1$2 {
        pub fn new(${3}) -> Self {
            $1 { $0 }
        }
    }

snippet pst "pub struct"
    #[derive(Debug)]
    #[must_use]
    pub struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
        ${0:${VISUAL}}
    }

snippet pcst "pub(crate) struct"
    #[derive(Debug)]
    #[must_use]
    pub(crate) struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
        ${0:${VISUAL}}
    }

snippet ty "Type alias"
    type ${1:Type} = $0;

snippet en "enum"
    #[derive(Debug)]
    #[must_use]
    enum ${1:name} {
        ${0:${VISUAL}}
    }

snippet pen "pub enum"
    #[derive(Debug)]
    #[must_use]
    pub enum ${1:name} {
        ${0:${VISUAL}}
    }

snippet pcen "pub(crate) enum"
    #[derive(Debug)]
    #[must_use]
    pub(crate) enum ${1:name} {
        ${0:${VISUAL}}
    }

snippet tr "trait"
    trait ${1:Name} {
        ${0:${VISUAL}}
    }

snippet pt "pub trait"
    pub trait ${1:Name} {
        ${0:${VISUAL}}
    }

snippet impl "impl" b
    impl ${1:Name} {
        ${0:${VISUAL}}
    }

snippet implt "impl Trait" b
    impl ${1:Trait} for ${2:Name} {
        ${0:${VISUAL}}
    }

snippet implg "impl (generic)" b
    impl<$2> ${1:Name}<${2:T}> {
        ${0:${VISUAL}}
    }

snippet idef "impl Default" b
    impl Default for ${1:Name} {
        fn default() -> Self {
            Self {
                ${0:${VISUAL}}
            }
        }
    }

snippet ifrom "impl From" b
    impl From<${1: Type}> for ${2:Name} {
        fn from(${3:val}: $1) -> Self {
            Self {
                ${0:${VISUAL}}
            }
        }
    }

snippet idbg "impl Debug" b
    impl std::fmt::Debug for ${1:Name} {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            ${0:${VISUAL}}
        }
    }

snippet idisp "impl Display" b
    impl std::fmt::Display for ${1:Name} {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            ${0:${VISUAL}}
        }
    }

snippet idrop "impl Drop" b
    impl Drop for ${1:Name} {
        fn drop(&mut self) {
            ${0:${VISUAL}}
        }
    }

snippet ideref "impl Deref" b
    impl Deref for ${1:Name} {
        type Target = ${2:Type};
        fn deref(&self) -> &Self::Target {
            &self.$0
        }
    }

snippet iderefm "impl DerefMut" b
    impl DerefMut for ${1:Name} {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.$0
        }
    }

snippet iasref "impl AsRef" b
    impl AsRef<${1:Ref}> for ${1:Type} {
        fn as_ref(&self) -> &${3:$1} {
            &self.$0
        }
    }

snippet iasmut "impl AsMut" b
    impl AsMut<${1:Ref}> for ${1:Type} {
        fn as_mut(&mut self) -> &${3:$1} {
            &mut self.$0
        }
    }

snippet test "test function"
    #[test]
    fn $1() {
        ${0:${VISUAL}}
    }

snippet testmod "test module" b
    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn ${1:name}() {
            ${0:${VISUAL}}
        }
    }

snippet bench "bench function" b
    #[bench]
    fn $1(b: &mut test::Bencher) {
        b.iter(|| {
            ${0:${VISUAL}}
        })
    }

snippet allow "allow lint attribute" b
    #[allow($1)]

snippet cfg "cfg attribute" b
    #[cfg($1)]

snippet feat "feature attribute" b
    #![feature($1)]

snippet der "derive" b
    #[derive(${1:Debug})]

snippet mu "must_use" b
    #[must_use]

snippet inl "inline" b
    #[inline]

snippet ig "#[ignore]" b
    #[ignore]

snippet attr "#[attr]" b
    #[$1]

snippet opt "Option<T>"
    Option<$1>

snippet res "Result<T, E>"
    Result<$1, ${2:Error}>

snippet if
    if $1 {
        ${0:${VISUAL}}
    }

snippet ife "if..else"
    if $1 {
        ${2:${VISUAL}}
    } else {
        $0
    }

snippet ifl "if let"
    if let ${1:name} = ${2:value} {
        ${0:${VISUAL}}
    }

snippet el "else"
    else {
        ${0:${VISUAL}}
    }

snippet eli "else if"
    else if $1 {
        ${0:${VISUAL}}
    }

snippet mat "match"
    match $1 {
        $2 => $3
    }

snippet case "match case"
    ${1:_} => $2

snippet ,, "=> "
    => $0

snippet loop "loop" b
    loop {
        ${0:${VISUAL}}
    }

snippet wh "while"
    while ${1} {
        ${0:${VISUAL}}
    }

snippet whl "while let"
    while let ${1:name} = ${2:value} {
        ${0:${VISUAL}}
    }

snippet for "for...in"
    for ${1:name} in ${2:value} {
        ${0:${VISUAL}}
    }

snippet unim "unimplemented!"
    unimplemented!($1);

snippet todo "# TODO"
    // TODO: $0

snippet fixme "# FIXME"
    // FIXME: $0

snippet td "todo!"
    todo!($1);

snippet dbg "dbg!"
    dbg!(&${0:${VISUAL}});

snippet as "assert!"
    assert!($1);

snippet ase "assert_eq!"
    assert_eq!(${1:expected}, ${2:actual});

snippet macro "macro_rules!" b
    macro_rules! $1 {
        ($2) => (
            ${0:${VISUAL}}
        )
    }

snippet box "Box::new()"
    Box::new(${0:${VISUAL}})
snippet rc "Rc::new()"
    Rc::new(${0:${VISUAL}})
