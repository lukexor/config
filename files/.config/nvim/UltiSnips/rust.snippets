snippet fn "fn" b
fn ${1:name}($2)${3/..*/ -> /}$3 {
    ${VISUAL}$0
}
endsnippet

snippet pfn "pub fn" b
pub fn ${1:name}($2)${3/..*/ -> /}$3 {
    ${VISUAL}$0
}
endsnippet

snippet pfc "pub(crate) fn" b
pub(crate) fn ${1:name}($2)${3/..*/ -> /}$3 {
    ${VISUAL}$0
}
endsnippet

snippet pfs "pub(super) fn" b
pub(super) fn ${1:name}($2)${3/..*/ -> /}$3 {
    ${VISUAL}$0
}
endsnippet

snippet afn "async fn" b
async fn ${1:name}($2)${3/..*/ -> /}$3 {
    ${VISUAL}$0
}
endsnippet

snippet pafn "pub async fn" b
pub async fn ${1:name}($2)${3/..*/ -> /}$3 {
    ${VISUAL}$0
}
endsnippet

snippet new "new" b
pub fn new(${2}) -> ${1:Self} {
    $1 { $0 }
}
endsnippet

snippet main "main" b
fn main() {
    ${VISUAL}$0
}
endsnippet

snippet pr "print!" b
print!("$1"${2/..*/, /}$2);
endsnippet

snippet prln "println!" b
println!("$1"${2/..*/, /}$2);
endsnippet

snippet fmt "format!"
format!("$1"${2/..*/, /}$2);
endsnippet

snippet st "Struct definition"
#[derive(Debug, Clone)]
#[must_use]
struct ${1:`!p snip.rv = ''.join(word.title() for word in snip.basename.split('_'))`} {
    ${VISUAL}$0
}
endsnippet

snippet stn "Struct with new constructor"
#[derive(Debug, Clone)]
#[must_use]
pub struct ${1:`!p snip.rv = ''.join(word.title() for word in snip.basename.split('_'))`} {
    ${VISUAL}$0
}

impl$2 $1$2 {
    pub fn new(${4}) -> Self {
        $1 { $0 }
    }
}
endsnippet

snippet pst "Pub struct definition"
#[derive(Debug, Clone)]
#[must_use]
pub struct ${1:`!p snip.rv = ''.join(word.title() for word in snip.basename.split('_'))`} {
    ${VISUAL}$0
}
endsnippet


snippet ty "Type alias"
type ${1:Type} = $0;
endsnippet

snippet en "enum"
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[must_use]
enum ${1:Name} {
    ${VISUAL}$0
}
endsnippet

snippet pen "pub enum"
#[must_use]
#[must_use]
pub enum ${1:Name} {
    ${VISUAL}$0
}
endsnippet

snippet tr "trait"
trait ${1:Name} {
    ${VISUAL}$0
}
endsnippet

snippet pt "pub trait"
pub trait ${1:Name} {
    ${VISUAL}$0
}
endsnippet

snippet impl "impl" b
impl ${1:type/trait}${2: for ${3:type}} {
    ${VISUAL}$0
}
endsnippet

snippet implg "impl (generic)" b
impl$4 ${1:type/trait}${2: for ${3:type}}${4:<${5:T}>} {
    ${VISUAL}$0
}
endsnippet

snippet idef "impl Default" b
impl Default for ${1:type} {
    fn default() -> Self {
        Self {
            ${VISUAL}$0
        }
    }
}
endsnippet

snippet ifrom "impl From" b
impl From<${1:type}> for ${2:type} {
    fn from(${3:value}: $1) -> Self {
        Self {
            ${VISUAL}$0
        }
    }
}
endsnippet

snippet idbg "impl Debug" b
impl fmt::Debug for ${1:type} {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        ${VISUAL}$0
    }
}
endsnippet

snippet idis "impl Display" b
impl fmt::Display for ${1:type} {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        ${VISUAL}$0
    }
}
endsnippet

snippet ideref "impl Deref" b
impl Deref for ${1:type} {
    type Target = ${2:targetType};
    fn deref(&self) -> &Self::Target {
        &self.$0
    }
}
endsnippet

snippet iderefm "impl DerefMut" b
impl DerefMut for ${1:type} {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.$0
    }
}
endsnippet

snippet test "test function"
#[test]
fn ${1:name}() {
    ${VISUAL}$0
}
endsnippet

snippet testmod "test module" b
#[cfg(test)]
mod tests {
    use super::${1:*};

    #[test]
    fn ${2:name}() {
        ${VISUAL}$0
    }
}
endsnippet

snippet allow "allow lint attribute" b
#[allow(${1:unused_variables})]
endsnippet

snippet cfg "cfg attribute" b
#[cfg(${1:target_os = "linux"})]
endsnippet

snippet feat "feature attribute" b
#![feature(${1:plugin})]
endsnippet

snippet der "derive" b
#[derive(${1:Debug})]
endsnippet

snippet mu "must_use" b
#[must_use]
endsnippet

snippet inl "inline" b
#[inline]
endsnippet

snippet attr "#[attr]" b
#[${1:inline}]
endsnippet

snippet opt "Option<T>"
Option<${1:i32}>
endsnippet

snippet res "Result<T, E>"
Result<${1:&str}, ${2:()}>
endsnippet

snippet if
if ${1} {
    ${VISUAL}$0
}
endsnippet

snippet ife "if..else"
if ${1} {
    ${2:${VISUAL}}
} else {
    ${0}
}
endsnippet

snippet ifl "if let"
if let ${1:Some($2)} = $3 {
    ${VISUAL}$0
}
endsnippet

snippet el "else"
else {
    ${VISUAL}$0
}
endsnippet

snippet eli "else if"
else if ${1} {
    ${VISUAL}$0
}
endsnippet

snippet mat "match"
match ${1} {
    ${2} => ${3}
}
endsnippet

snippet case "match case"
${1:_} => ${2:expression}
endsnippet

snippet ,, "=> "
=> $0
endsnippet

snippet loop "loop" b
loop {
    ${VISUAL}$0
}
endsnippet

snippet wh "while"
while ${1:condition} {
    ${VISUAL}$0
}
endsnippet

snippet whl "while let"
while let ${1:Some($2)} = $3 {
    ${VISUAL}$0
}
endsnippet

snippet for "for...in"
for ${1:i} in ${2} {
    ${VISUAL}$0
}
endsnippet

snippet unim "unimplemented!()"
unimplemented!($1);
endsnippet

snippet todo "todo!()"
todo!($1);
endsnippet
