" ==========================================================
" == vimrc
"
" AUTHOR
"    Lucas Petherbridge

" ==========================================================
" == Startup
" Use vim settings rather than vi
" Must be first because it changes other options

set nocompatible

" ==========================================================
" == Pathogen Initialization
" Load all plugins in ~/.vim-runtime/bundle

if v:version > 700
  let g:pathogen_disabled = ['snipmate', 'delimitMate']
  call pathogen#helptags()
  call pathogen#infect()
endif

" ==========================================================
" == General Config

let g:snips_author = 'Lucas Petherbridge' " Set author for snippets
let g:snips_authoremail = 'lukexor@gmail.com'
let g:snippets_dir = "~/.vim-runtime/snippets" " Set snippets directory
let g:yankring_history_dir = "~/.vim-runtime"
let g:ycm_collect_identifiers_from_tags_files = 1

let ft = &filetype
set tags=./tags

" Tell vim to remember certain things when we exit
" '100  : marks will be remembered for up to 100 previously edited files
" f1   :  enable capital marks
" "100 :  will save up to 100 lines for each register
" :20  :  up to 20 lines of command-line history will be remembered
" %  :  saves and restores the buffer list
" n... :  where to save the viminfo files
set viminfo='100,f1,"100,:20,%,n~/.viminfo

if has("autocmd")
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
endif

set grepprg=grep\ -nH\ $* " Set grep to always print filename headers
set autoread " Set to auto read when a file is changed from the outside
set hidden " Hide buffers instead of closing them
set history=1000 " Set how many lines vim has to remember
set undolevels=1000 " How many undos

" ==========================================================
" == Display Settings

set background=dark " Dark BG is good
set background=dark " Dark BG is good
set encoding=utf8 " UTF8 encoding is best
set ff=unix
set ffs=unix,dos,mac " Default file types
set number " Line numbers
set cpoptions+=n

set t_Co=256 " Force 256 colors
set encoding=utf8 " UTF8 encoding is best
set ff=unix
set ffs=unix,dos,mac " Default file types
set number " Line numbers
set cpoptions+=n

set t_Co=256 " Force 256 colors
colorscheme zhayedan " Custom colorscheme

syntax enable
let perl_include_pod = 1 " Syntax highlight pod documentation correctly
let perl_extended_vars = 1 " Syntax color complex things like @{${'foo'}}
set cursorline

" Default Colors for CursorLine
highlight  CursorLine ctermbg=017 ctermfg=None

" Change Color when entering Insert Mode
autocmd InsertEnter * highlight  CursorLine ctermbg=235 ctermfg=None

" Revert Color to default when leaving Insert Mode
autocmd InsertLeave * highlight  CursorLine ctermbg=017 ctermfg=None


" ==========================================================
" == Status Settings

set laststatus=2 " Always show the statusline

set title
" Format the statusline
set statusline=%F    " Tail of the filename
set statusline+=\ [%{strlen(&fenc)?&fenc:'none'}, " File encoding
set statusline+=%{&ff}] " File format
set statusline+=[fo:%{&fo}] " Formatoptions enabled
set statusline+=\ %y    " Filetype
set statusline+=[%{CurDir()}] " Current directory
set statusline+=%m    " Modified flag
set statusline+=%r    " Read only flag
set statusline+=%{HasPaste()} " Whether pastemode is on or not
set statusline+=%=    " Left/right separator
set statusline+=Line:%l/%L, " Cursor line/total lines
set statusline+=\ Col:%c   " Cursor column
set statusline+=\ (%p%%)   " Percent through file
if v:version > 700
  set statusline+=\ %{exists('g:loaded_fugitive')?fugitive#statusline():''} " Git status
endif

" ==========================================================
" == Usage settings

set backspace=eol,start,indent " Set backspace config, allowing backspace in insert mode
set cmdheight=2 " The commandbar height
set hlsearch " Highlight search things
set ignorecase " Ignore case when searching
set incsearch " Make search act like search in modern browsers
set mat=2 " How many tenths of a second to blink
set nolazyredraw " Don't redraw while executing macros
set novisualbell " No visual errors either
set noerrorbells " No sound on errors
set ruler " Always show current position
set showcmd " Display incomplete commands
set showmatch " Show matching brackets when text indicator is over them
set showmode " Show current mode
set smartcase " Ignores the above when searching for UPPERcase
set so=7 " Set 7 lines to the cusrors - when moving vertical..
set ttyfast " Smoother changes
set t_vb= " Unsets the visual bell termcap code
set whichwrap+=<,> " Allow left/right arrow keys move to the next line

" ==========================================================
" == Fold options

if exists('&foldenable')
  set foldmethod=expr " Fold based on indent
  set foldexpr=GetFoldLevel(v:lnum)
  set foldnestmax=5 " Deepest fold
  set foldlevel=1 " The default depth to fold
  set foldenable
  set foldminlines=1

  function! NextNonBlankLine(lnum)
    let numlines = line('$')
    let current = a:lnum + 1

    while current <= numlines
      if getline(current) =~? '\v\S'
        return current
      endif

      let current += 1
    endwhile

    let invalid_line = -2
    return invalid_line
  endfunction

  function! IndentLevel(lnum)
    return indent(a:lnum) / &shiftwidth
  endfunction

  function! GetFoldLevel(lnum)
    let undefined_fold_level = '-1'

    if getline(a:lnum) =~? '\v^\s*$'
      return undefined_fold_level
    endif

    let this_indent = IndentLevel(a:lnum)
    let next_indent = IndentLevel(NextNonBlankLine(a:lnum))

    if next_indent == this_indent
      return this_indent
    elseif next_indent < this_indent
      return this_indent
    elseif next_indent > this_indent
      return '>' . next_indent

    return '0'
  endfunction
endif

" ==========================================================
" == Disable Swap Files

" Turn backup off, since most stuff is in SVN & Git anyway...
set nobackup
set noswapfile
set nowb

" ==========================================================
" == Persistent Uundo

" Keep undo history across sessions by storing in a file
if exists('&undofile')
  silent !mkdir ~/.vim-runtime/undodir > /dev/null 2>&1
  set undodir=~/.vim-runtime/undodir
  set undofile
endif

" ==========================================================
" == Formatting

set autoindent
set expandtab " Always expand tabs into spaces
set formatoptions=rql " Allow line-width formatting with <leader>gq
set linebreak " Wrap long lines at a character in breakat
set list listchars=tab:\|\ ,trail:-,extends:>,precedes:<,nbsp:x " display indentation guides
highlight SpecialKey ctermfg=darkgrey guifg=darkgrey
set wrap " wrap default
set shiftround " Indent/Outdent to nearest tabstop
set matchpairs+=<:> " Allow % to bounce between angles too
set smarttab " Tabs according to shiftwidth
set shiftwidth=2 " Number of spaces used for each indent level
set softtabstop=2 " Spaces a tab counts for when backspacing or inserting tabs
set tabstop=2 " The number of spaces a tab counts as
set textwidth=80
set wrapmargin=10 " Number of characters from the right where wrapping starts
if has('spell')
  set spelllang=en
endif

filetype plugin indent on " Enable filetype plugin

" ==========================================================
" == Completion

set wildmenu " Turn on WiLd menu for name completion
set wildmode=list:longest " Bash like name-completion
set wildignore=*.o,*.obj,*~ "stuff to ignore when tab completing
set wildignore+=*vim-runtime/undodir*
set wildignore+=*.gem
set wildignore+=log/**
set wildignore+=tmp/**
set wildignore+=*.png,*.jpg,*.gif
set wildignore+=*.swp,*.bak,*.pyc,*.class
set wildignore+=*/build/**

" ==========================================================
" == Scrolling

set scrolloff=8 " Scroll when 8 lines away from margin
set sidescrolloff=15 " Scroll when 15 lines away from margin
set sidescroll=1 " Minimum number of columns to scroll horizontally

" ==========================================================
" == Plugin Settings

let MRU_Max_Entries = 400 " Most Recently Used files
let NERDTreeMouseMode = 2 " Single click for directories, double click for files
let NERDChristmasTree = 1
let NERDTreeAutoCenter = 1
let NERDTreeDirArrows = 1
let NERDTreeWinSize = 35
let NERDTreeMapOpenInTab = '<CR>'
let g:tagbar_width = 25
let g:showmarks_enable = 0 " Enable showmarks by default
highlight ShowMarksHLl guifg=#DA4939 ctermfg=167 gui=NONE cterm=NONE " a-z marks
highlight ShowMarksHLu guifg=#DA4939 ctermfg=167 gui=NONE cterm=NONE " A-Z marks
highlight ShowMarksHLo guifg=#2B2B2B ctermfg=159 guibg=#C0C0FF " All other marks
highlight ShowMarksHLm guifg=#DA4939 ctermfg=167 gui=NONE cterm=NONE " Multiple marks on same line
let delimitMate_expand_cr = 1
let g:syntastic_mode_map = { 'mode': 'passive' }
let g:UltiSnipsSnippetDirectories=["UltiSnips", "UltiSnips_custom"]

" ==========================================================
" == Mappings

let mapleader = "\<Space>" "With a map leader it's possible to do extra key combinations
let g:mapleader = "\<Space>"
let g:ycm_key_list_select_completion = ['<C-TAB>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-S-TAB>', '<Up>']
let g:SuperTabDefaultCompletionType = '<C-Tab>'
let g:SuperTabNoCompleteAfter = ['^', ',', '\s', '\t']
let g:SuperTabNoCompleteBefore = ['\n', '$', '\s', '\t']
let g:user_zen_leader_key = '<leader>z' " zencoding
nnoremap ; :
nnoremap ` <NOP>

" ----------------------------------------------------------
" -- Navigation

" Navigate by screen lines instead of file lines
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk

set mouse=a
set ttymouse=xterm2

nnoremap <C-j> 12j
nnoremap <C-k> 12k
vnoremap <C-j> 12j
nnoremap <C-k> 12k

" Map 0 to move cursor to beginning of line
map 0 ^

" Show yank ring window
nnoremap <leader>y :YRShow<CR>

" Change NERDTree to current file directory
nnoremap <leader>nc :NERDTreeFind<CR>:2wincmd w<CR>

" ----------------------------------------------------------
" -- Search

" In visual mode when you press * to search for the current selection
vnoremap <silent> * :call VisualSearch('f')<CR>

" When you press gv you vimgrep after the selected text
vnoremap <silent> gv :call VisualSearch('gv')<CR>
vnoremap <silent> gv :call VisualSearch('gv')<CR>

" ----------------------------------------------------------
" -- Settings Toggle

" Show shortcuts
nmap <F1> :10split ~/.vim-runtime/shortcuts<CR>gg:wincmd j<CR>
imap <F1> <Esc>:10split ~/.vim-runtime/shortcuts<CR>gg:wincmd j<CR>i

nmap <F2> :call ToggleSideBars()<CR>
imap <F2> <Esc>:call ToggleSideBars()<CR>i

nmap <F3> :set invpaste paste?<CR>
imap <F3> <Esc>:set invpaste paste?<CR>i

nmap <F4> :set wrap!<CR>:set list!<CR>
imap <F4> <Esc>:set wrap!<CR>:set list!<CR>i

nmap <F5> :set invnu<CR>:set list!<CR>
imap <F5> <Esc>:set invnu<CR>:set list!<CR>i

nmap <F6> :SyntasticCheck<CR>
imap <F6> <Esc>:SyntasticCheck<CR>i

nmap <F7> :call ToggleMouse()<CR>
imap <F7> <Esc>:call ToggleMouse()<CR>i

nmap <F8> :call ToggleTextMode()<CR>
imap <F8> <Esc>:call ToggleTextMode()<CR>i

" ----------------------------------------------------------
" -- Formatting

" Make tab indent code
vmap <tab> >gv
vmap <s-tab> <gv
nmap <tab> >>
nmap <s-tab> <<

" Run perltidy in visual mode
vmap <leader>p :!perltidy --quiet --standard-output --nostandard-error-output<CR>

map <leader>l :rightb vnew<cr>

" Remove the Windows ^M - when the encodings gets messed up
map <leader>wm mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm

" Pressing ,ss will toggle and untoggle spell checking
map <leader>ss :setlocal spell!<cr>

" Next misspelled word
map <leader>sn ]s
" Previous misspelled word
map <leader>sp [s
" Add highlighted word
map <leader>sa zg
" Remove highlighted word
map <leader>sr zw
" List spelling corrections
map <leader>s? z=

" ----------------------------------------------------------
" -- Auto-complete

" Smart mappings on the command line
cno $c e <C-\>eCurrentFileDir("e")<cr>

" ----------------------------------------------------------
" -- Plugins

" CtrlP
nnoremap <leader>o :CtrlP<CR>
nnoremap <leader>ot :CtrlPTag<CR>
nnoremap <leader>or :CtrlPMRU<CR>

let g:ctrlp_open_new_file = 't' " Open new files in a tab
" disable caching
let g:ctrlp_use_caching = 0
if executable('ag')
    set grepprg=ag\ --nogroup\ --nocolor
    let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
else
  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files . -co --exclude-standard', 'find %s -type f']
  let g:ctrlp_prompt_mappings = {
    \ 'AcceptSelection("e")': ['<space>', '<cr>', '<2-LeftMouse>'],
    \ }
endif

" ----------------------------------------------------------
" -- Tabs

" Tab configuration
nmap <leader>tn :tabnew<cr>
nmap <leader>te :tabedit 
nmap <leader>tc :tabclose<cr>
nmap <leader>tm :tabmove 
nmap <leader><up> :tabr<cr>
nmap <leader><down> :tabl<cr>
nmap <leader><left> :tabp<cr>
nmap <leader><right> :tabn<cr>

" ----------------------------------------------------------
" -- Quick Shortcuts

" Fast saving
map <leader>w :w!<cr>

" execute current file
autocmd FileType ruby map <leader>r :call RunWith("ruby")<cr>
autocmd FileType python map <leader>r :call RunWith("python")<cr>
autocmd FileType perl map <leader>r :call RunWith("perl")<cr>
autocmd FileType cpp map <leader>r :FILES=$(find . -iname '*.cpp' -o -iname '*.o') g++ $FILES<cr>

map <leader>m :make<CR>

" Source vimrc
map <leader>sv :so ~/.vim-runtime/vimrc<cr>

" Fast editing of various files
map <leader>ev :tabnew ~/.vim-runtime/vimrc<cr>
map <leader>ep :execute 'sp ~/.vim-runtime/UltiSnips_custom/' . &filetype . '.snippets'<cr>

" Quit all windows without saving
map <leader>q :qall!<cr>

" Remove trailing whitespace
map <leader>rs :%s/\s\+$//<cr>:noh<cr>

" Replace tabs with spaces
" map <leader>rt :%s/\t/  /g<cr>:noh<cr>
map <leader>rt :%retab!<cr>

" Disable search highlighting
map <leader><cr> :nohlsearch<cr>

" Change to current working directory of file being edit
map <leader>c :lcd %:p:h<cr>

" Write a file with sudo
cmap w!! w !sudo tee % >/dev/null

" ==========================================================
" == Functions

" NERDTree Tagbar toggle
function! ToggleSideBars()
  if exists("b:sidebars") && b:sidebars
    echo "sidebars off"
    NERDTreeClose
    TagbarClose
    2wincmd w
    let b:sidebars = 0
  else
    echo "sidebars on"
    if filereadable(expand('%:p'))
      NERDTreeFind
    else
      NERDTree
    endif
    TagbarOpen
    2wincmd w
    let b:sidebars = 1
  endif
endfunction

function! MirrorSideBars()
    NERDTreeMirror
    TagbarOpen
    2wincmd w
endfunction

" Toggle mouse use
function! ToggleMouse()
  if !exists("s:old_mouse")
    let s:old_mouse = "a"
  endif

  if &mouse == ""
    let &mouse = s:old_mouse
    echo "Mouse is for Vim (" . &mouse . ")"
  else
    let s:old_mouse = &mouse
    let &mouse=""
    echo "Mouse is for terminal"
  endif
endfunction

" Highlights lines longer than 80 chars
function! ToggleOverLengthHi()
  if exists("b:overlengthhi") && b:overlengthhi
    highlight clear OverLength
    let b:overlengthhi = 0
    echo "overlength hilight off"
  else
    highlight OverLength ctermfg=black ctermbg=lightgrey guibg=#592929
    match OverLength /\%81v.\+/
    let b:overlengthhi = 1
    echo "overlength hilight on"
  endif
endfunction

" Save and run the command, measuring time it takes to run
function! RunWith(command)
  execute "w"
  execute "!clear;time " . a:command . " " .expand("%:p")
endfunction

" Visual search function
function! VisualSearch(direction) range
  let l:saved_reg = @"
  execute "normal! vgvy"

  let l:pattern = escape(@", '\\/.*$^~[]')
  let l:pattern = substitute(l:pattern, "\n$", "", "")

  if a:direction == 'b'
    execute "normal ?" . l:pattern . "^M"
  elseif a:direction == 'f'
    execute "normal /" . l:pattern . "^M"
  endif

  let @/ = l:pattern
  let @" = l:saved_reg
endfunction

" Gets current directory and replaces $HOME with, also trims to 40 chars
function! CurDir()
  let curdir = substitute(getcwd(), $HOME, "~", "g")
  if strlen(curdir) > 40
    return "..." . curdir[-40:]
  else
    return curdir
  endif
endfunction

" Get current working directory
function! Cwd()
  let cwd = getcwd()
  return "e " . cwd
endfunction

" Get current file directory
function! CurrentFileDir(cmd)
  return a:cmd . " " . expand("%:p:h") . "/"
endfunction

" Returns [PASTE] if pastemode is enabled
function! HasPaste()
  if &paste
    return '[PASTE] '
  else
    return ''
  endif
endfunction

" Toggle text editor like formatting
" t - auto-wrap text using textwidth
" a - Every time text is inserted/deleted the paragraph will be reformatted
" w - trailing white space indiates paragraph continues to next line
" n - recognize numbered lists
" 2 - Use indent of second line of paragraph when formatting
function! ToggleTextMode()
  if exists("b:textmode") && b:textmode
    set formatoptions-=tawn2
    let b:textmode = 0
    echo "text mode off"
  else
    let b:textmode = 1
    set formatoptions+=tawn2
    echo "text mode on"
  endif
endfunction

" ==========================================================
" == Auto Commands

autocmd! bufwritepost vimrc source ~/.vim-runtime/vimrc " When vimrc is edited, reload it

autocmd FileType perl source ~/.vim-runtime/perltest.vim

" Open NERDTree automatically
" autocmd vimenter * call ToggleSideBars()
" autocmd BufNewFile * call MirrorSideBars()
if v:version > 702
  set colorcolumn=+1
  highlight ColorColumn ctermbg=235 guibg=235
endif

" Closes if NERDTree is the only open window
autocmd BufEnter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

" Make sure the syntax is always right, even when in the middle of
" a huge javascript inside an html file.
autocmd BufEnter * :syntax sync fromstart
autocmd BufEnter * if &filetype == "" | set ft=txt | endif " Sets default filetype to txt
" autocmd BufNewFile,BufRead *.html set filetype=htmldjango
autocmd BufEnter *.conf set ft=yaml
autocmd BufEnter *.t set ft=perl

" Check perl syntax with :make
autocmd FileType perl set makeprg=perl\ -c\ %\ $*
autocmd FileType perl set errorformat=%f:%l%m

" autocmd QuickFixCmdPost [^l]* nested copen 3
" autocmd QuickFixCmdPost    l* nested lwindow
